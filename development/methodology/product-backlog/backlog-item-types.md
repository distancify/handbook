[Handbook](../../README.md) / Development / Methodology / Product Backlog

# Backlog Item Types

## Epic

*Epics* model individual projects at a particular client. Often, a client has different budgets for different Epics.

## Feature

Features explain strategic goals and is often modeled around how the business itself thinks about the various efforts that takes place within a project. It's the level at which the Client Sponsor and Client Management is operating, and serves as a good framework for reporting overall progress of a project. Examples of Features could be delivering the checkout and order management flow, or launching in a new market.

## Product Backlog Item (PBI)

We use the term Product Backlog Item (or PBI, yes we actually refers to it as "PBI" in speech) to refer to an item in a backlog. "PBI" can be seen as a carrier of *User Stories*.

Note that PBIs can contain multiple user stories that all align around a given feature. So in one sense, a PBI can be referred to as a Feature. However, the term *Feature* is used to group multiple PBIs into a coherent strategic goal useful for communicating with Client Management (see [Feature](#feature) above). Therefor we consistently use the term "PBI" when referring to a PBI. Although, sometimes during refinement meetings, a PBI is deemed to big, in which case it is made into a feature and split into multiple PBIs.

The PBIs title is usually a short summary of what the PBI expects to result in, the user stories *What*.

### User Stories

Although PBIs can be formal requirement documents, we prefer the use of User Stories, as it invites more collaboration from th team.

A User Story must answer the following questions:

- Who\
Example: A customer who is looking for a particular brand
- What\
Example: Should be able to search for a brand using text input
- Why\
Example: The business carries 400 brands, and it's difficult to find a brand without typing it.

Often, we put all of this into a sentence to form a sort of requirement:

> As a customer who is looking for a particular brand, I should be able to search for a brand using text input as the list of 400 brands is very difficult to browse through.

The user story leaves room for discussion. The team will later discuss the *What* in the [Backlog Refinement meeting](backlog-refinement.md), but the initial suggested solution serves as a good starting point for the discussion.

### Acceptance Criteria

Acceptance criterias are noted down as scenarios using the [Cucumber/Gherkin syntax](https://docs.cucumber.io/gherkin/reference/). These scenarios serve both as acceptance criterias and can quite easily be transformed into acceptance tests.

### Constraints

Sometimes, there are specific constraints that constrain the solution in various ways. These can be technical or business. To continue on the user story example above, there may have been a contraint saying that the order of the brands list must not be change, as it's sorted based on popularity.

## Bugs

We don't estimate bugs. Bugs are mistakes generated by us and we take full responsibility for our mistakes. Therefor Bugs should slow us down. They should lower the velocity. We must work harder to keep our pace if we introduce bugs.

For this to work, we need to have a clear definition of what a bug is.

### A bug is something that is:

- Prevents the user from accomplishing the task that the system is designed to perform or
- Prevents the system to fulfill the need that the system was designed to fulfill
- Can be tied to a previous change made by the team

### A bug is not (unless it's also anything of the above):

- Something that can be improved
- A behavior that is unexpected from the user's perspective. Because expectations are subjective and there are billions of people with different expectations. This is merely a matter of quality. A high quality system meets the expectations of most of it's users.

### Anatomy of a Bug

Since by definition, a bug is always tied to previous work, we can always assume that there is always a PBI that introduced the bug. Therefor, bugs always need to reference the PBI that it originated from. A bug always re-opens a PBI until the fix is done, judging by the Definition of Done for the team.

Apart from a reference to a previous PBI, a bug must include:

- The steps needed to reproduce/demonstrate the issue, either as a numbered list or a video. Clarity is more important than format.
- An explanation why this is a bug and what the expected behaviour should be

Feel free to use the following template when creating a bug:

```
Perform the following steps:

1.

According to the PBI that stated [...]
At step #, the system should have [...]
```

Here's an example of a good bug report:

```
Perform the following steps:

1. Go to a product listings page
2. Resize the screen/viewport so that it's smaller than 768px
3. Notice that the facets in the sidebar disappears as the viewport shrink

According to the PBI that stated that visitors (regardless of device) should be able to filter the products.
At step 3, the system should have allowed the user to filter the products using the facets.
```

### Managing bugs in Azure DevOps (Visual Studio Team Services)

In Azure DevOps, Team Sprint Boards are configured to manage bugs as sub-tasks of PBIs. This means that all bugs must have a parent PBI, and can not have child Tasks. Apart from that, Bugs and managed in the same way as regular Tasks.

When a bug is found in a PBI marked as "Done", the PBI must be re-opened until the bug is fixed. Bugs are generally put into the the current sprint.